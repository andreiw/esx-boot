/*
 * SPDX-License-Identifier: BSD-3-Clause
 */

/*
 * Useful macros to code in assembly with clarity
 * and convenience.
 *
 * _Do_ use defun_global/defun/retfun and push/pop macros
 * in assembly that get called from other bits of asm,
 * unless you have a really good reason to. Writing
 * throw-away initialization functions is not a good
 * reason. Writing interrupt handlers or perf-sensitive
 * code may be.
 *
 * To simplify the mental tax, any function defined via
 * defun_global/defun must assume all registers are callee
 * saved. Any caller of a function defined via defun_global/
 * defun can thus skip saving _any_ register.
 *
 * The trade-off here is having less efficient code, yet
 * code that is robust in the face of long term maintainability.
 * The efficiency aspect is overall irrelevant when it comes
 * to throw-away initialization code that is executed once.
 */

/*
 * Helps enforce correct usage of macros and their parameters,
 * by catching invalid macro parameter values.
 *
 * What 'x' and 'y' are is pretty flexible, these can be
 * references to macro params, can be registers or even values.
 *
 * E.g.:
 * - macro_arg_is_not \level, 4, "level cannot be \level"
 * - macro_arg_is_not \reg, a0, "reg cannot be a0"
 * - macro_arg_is_not \a, \b, "a cannot be b"
 */
.macro macro_arg_is_not x, y, err
   .if typeof_\x == typeof_\y
      .error "\err"
   .endif
.endm

/*
 * Begins a function.
 *
 * Function prologue just sets a frame pointer.
 */
.macro defun name
\name:
   sd   ra, -8(sp)
   sd   s0, -16(sp)
   mv   s0, sp
   addi sp, sp, -16
.endm

/*
 * Begins a globally-visible function.
 */
.macro defun_global name
   .global \name
   defun name=\name
.endm

/*
 * Completes a function.
 *
 * Function epilogue only uses frame pointer to
 * restore state. I.e. it doesn't matter what SP
 * was.
 */
.macro retfun
   mv   sp, s0
   ld   s0, -16(sp)
   ld   ra, -8(sp)
   ret
.endm

/*
 * Push \reg onto stack.
 */
.macro push reg
   addi sp, sp, -8
   sd   \reg, 0(sp)
.endm

/*
 * Pop stack into \reg.
 */
.macro pop reg
   ld   \reg, 0(sp)
   addi sp, sp, 8
.endm

/*
 * Call a C function.
 *
 * Ensures the stack is 16 byte aligned.
 */
.macro call_c sym
   push s1
   push t0
   mv   s1, sp
   andi t0, sp, 8
   beq  t0, zero, m\@_0
   addi sp, sp, -8
m\@_0:
   call \sym
   mv   sp, s1
   pop  t0
   pop  s1
.endm

/*
 * Fatal error.
 */
.macro fatal str
   debug_string \str
   call panic
.endm

#ifdef DEBUG
/*
 * Define a NUL-terminated ASCII string for use with
 * debug macros below.
 */
.macro debug_asciz sym, str
 \sym:
    .asciz "\str"
.endm

/*
 * Print a \str.
 */
.macro debug_string str
   push a0
   la   a0, \str
   jal  sbi_putstring
   pop  a0
.endm

/*
 * Print a \str and a 64-bit hex value stored in \reg.
 *
 * This is written weirdly to allow reg to be a0.
 */
.macro debug_string_reg str, reg
   push a0
   la   a0, \str
   jal  sbi_putstring
   pop  a0
   push a0
   mv   a0, \reg
   jal  sbi_puthex64
   pop  a0
.endm

/*
 * Print a \str and a 64-bit hex value at the address
 * specified by \reg.
 *
  * This is written weirdly to allow reg to be a0.
 */
.macro debug_string_dereg_val64 str, reg
   push a0
   la   a0, \str
   jal  sbi_putstring
   pop  a0
   push a0
   mv   a0, \reg
   ld   a0, 0(a0)
   jal  sbi_puthex64
   pop  a0
.endm

/*
 * Print a \str and a 64-bit hex address of \sym.
 */
.macro debug_string_sym str, sym
   push a0
   la   a0, \str
   jal  sbi_putstring
   la   a0, \sym
   jal  sbi_puthex64
   pop  a0
.endm

/*
 * Print a \str and a 64-bit hex value stored at \sym.
 */
.macro debug_string_sym_val64 str, sym
   push a0
   la   a0, \str
   jal  sbi_putstring
   la   a0, \sym
   ld   a0, 0(a0)
   jal  sbi_puthex64
   pop  a0
.endm
#else
/*
 * On non-debugging builds all of these do nothing.
 */

.macro debug_asciz sym, str
.endm

.macro debug_string str
.endm

.macro debug_string_reg str, reg
.endm

.macro debug_string_dereg_val64 str, reg
.endm

.macro debug_string_sym str, sym
.endm

.macro debug_string_sym_val64 str, sym
.endm
#endif